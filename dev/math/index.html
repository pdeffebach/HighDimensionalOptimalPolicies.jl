<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Appendix · High Dimensional Optimal Policies</title><meta name="title" content="Mathematical Appendix · High Dimensional Optimal Policies"/><meta property="og:title" content="Mathematical Appendix · High Dimensional Optimal Policies"/><meta property="twitter:title" content="Mathematical Appendix · High Dimensional Optimal Policies"/><meta name="description" content="Documentation for High Dimensional Optimal Policies."/><meta property="og:description" content="Documentation for High Dimensional Optimal Policies."/><meta property="twitter:description" content="Documentation for High Dimensional Optimal Policies."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">High Dimensional Optimal Policies</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Mathematical Appendix</a><ul class="internal"><li><a class="tocitem" href="#The-Standard-Optimal-Policy-Problem"><span>The Standard Optimal Policy Problem</span></a></li><li><a class="tocitem" href="#The-Relaxed-Optimal-Policy-Problem"><span>The Relaxed Optimal Policy Problem</span></a></li><li><a class="tocitem" href="#The-Metropolis-Hastings-Algorithm-for-Calculating-Optimal-Policies"><span>The Metropolis-Hastings Algorithm for Calculating Optimal Policies</span></a></li><li><a class="tocitem" href="#Simulated-Annealing-and-Parallel-Tempering-for-Metropolis-Hastings"><span>Simulated Annealing and Parallel Tempering for Metropolis-Hastings</span></a></li><li><a class="tocitem" href="#Testing-for-optimal-mixing"><span>Testing for optimal mixing</span></a></li></ul></li><li><a class="tocitem" href="../optimal_transport/">Optimal Transport Example</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Mathematical Appendix</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical Appendix</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/pdeffebach/HighDimensionalOptimalPolicies.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/pdeffebach/HighDimensionalOptimalPolicies.jl/blob/main/docs/src/math.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-Appendix"><a class="docs-heading-anchor" href="#Mathematical-Appendix">Mathematical Appendix</a><a id="Mathematical-Appendix-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Appendix" title="Permalink"></a></h1><h2 id="The-Standard-Optimal-Policy-Problem"><a class="docs-heading-anchor" href="#The-Standard-Optimal-Policy-Problem">The Standard Optimal Policy Problem</a><a id="The-Standard-Optimal-Policy-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Standard-Optimal-Policy-Problem" title="Permalink"></a></h2><p>The researcher starts with model economy which is parametrized according to estimated parameters <span>$\hat{\theta}$</span>. Denote <span>$N \in \mathcal{N}$</span> to be a &quot;policy&quot; within the the model. For any given pair of parameter estimates <span>$(\hat{\theta}, N)$</span> we can generate a welfare level <span>$W(N; \hat{\theta}) \in \mathbb{R}$</span>. In this way, we can compare policies <span>$N, N&#39; \in \mathcal{N}$</span>. </p><p>For example, the consider a model of the transportation throughout the city, where <span>$\hat{\theta}$</span> represents, among other things, the preferences of households for taking the car vs. the bus, or the speed of various transportation modes. In this example, <span>$\mathbb{N}$</span> represents the set of public transportation routes throughout the city. </p><p>The researcher wishes to advise the policy-maker on the optimal policy. That is, they want to find</p><p class="math-container">\[N^* \in \arg \max_{N} W(N; \hat{\theta})\]</p><p>Consider the case where <span>$N$</span> is high-dimensional or otherwise difficult to characterize and where <span>$\mathcal{N}$</span> either a very large discrete set or an otherwise large continuous space. In this scenario, we face two main constraints. </p><ol><li>he high dimensionality of <span>$N$</span> can make conventional descent-based optimization methods prohibitively computationally expensive. </li><li>The large state space of <span>$\mathcal{N}$</span> makes it difficult to ensure the we have correctly identified the global best policy <span>$N^*$</span> as opposed to one of many local optima. </li></ol><h2 id="The-Relaxed-Optimal-Policy-Problem"><a class="docs-heading-anchor" href="#The-Relaxed-Optimal-Policy-Problem">The Relaxed Optimal Policy Problem</a><a id="The-Relaxed-Optimal-Policy-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Relaxed-Optimal-Policy-Problem" title="Permalink"></a></h2><p>To solve these issues, we re-characterize the optimal policy problem such that our optimal policy <span>$N^*$</span> is now defined as</p><p class="math-container">\[N^* \in \arg \max W(N; \hat{\theta}) + \epsilon_N\]</p><p>where <span>$\epsilon_N$</span> is an i.i.d extreme value type-I distribution with dispersion parameter <span>$\beta$</span>. That is, a <span>$\text{Gumble}(\beta^{-1})$</span>.</p><p>In this relaxed problem, <span>$\epsilon_N$</span> is unobserved by the researcher. This might represent, for example, social welfare factors that are not in the model, or idiosyncratic policy effects that are not observed by the researcher. In the relaxed problem, <span>$\beta$</span>, the dispersion of errors <span>$\epsilon_N$</span> is also unobserved by the researcher and the researcher must make assumptions about its value. </p><p>This re-characterization of the optimal problem now implies that, from the researcher&#39;s perspective, <em>any</em> policy <span>$N \in \mathcal{N}$</span> could be the optimal policy <span>$N^*$</span>, given a high enough unobserved value of the idiosyncratic shock <span>$\epsilon_N$</span>. As a consequence, the researcher is no longer in searching for the <em>single</em> optimal policy, now seeks to characterize policies by the <em>probability</em> that a given policy is optimal. </p><p>Given standard results about multinomial logit probabilities, we define the probability that a given policy <span>$N$</span> is optimal as</p><p class="math-container">\[\mathbb{P}(N \text{optimal}) = \pi_\beta(N) = \frac{\exp{\beta W(N; \hat{\theta})}}{\sum_{N&#39; \in \mathcal{N}} \exp{\beta W(N&#39;; \hat\theta)}}\]</p><p>Our goal, then, is to estimate <span>$\pi_\beta(N)$</span>. </p><h2 id="The-Metropolis-Hastings-Algorithm-for-Calculating-Optimal-Policies"><a class="docs-heading-anchor" href="#The-Metropolis-Hastings-Algorithm-for-Calculating-Optimal-Policies">The Metropolis-Hastings Algorithm for Calculating Optimal Policies</a><a id="The-Metropolis-Hastings-Algorithm-for-Calculating-Optimal-Policies-1"></a><a class="docs-heading-anchor-permalink" href="#The-Metropolis-Hastings-Algorithm-for-Calculating-Optimal-Policies" title="Permalink"></a></h2><p>Given our constraints, listed above, that <span>$N$</span> is both high dimensional and <span>$\mathcal{N}$</span> is a large set, it is intractable to compute or estimate the probabilities <span>$\pi_\beta(N)$</span> explicitly. To compensate for this, instead of analyzing features of <span>$\pi_\beta(N)$</span>, we generate a set of &quot;likely optimal policies&quot;</p><p>Instead, our goal is to sample optimal policies from the distribution <span>$\pi_\beta(N)$</span> without fully characterizing <span>$\pi_\beta(N)$</span>. We accomplish this through the Metropolitan-Hastings algorithm. </p><p>At a high level, the Metropolitan-Hastings algorithm is a Markov Chain Monte-Carlo algorithm for sampling from a probability distribution which is difficult to characterize. It is an iterative procedure which takes as an input an initial &quot;guess&quot; of an initial Markov Chain and over time will characterize a Markov Chain whose stationary distribution corresponds to the distribution of interest. The exposition of this section borrows from Levin and Peres (2017).</p><p>Fixing ideas, consider an initial Markov chain <span>$\Psi$</span> which is both aperiodic and irreducible, and satisfies <span>$\Psi(N, N&#39;) &gt; 0 \iff \Psi(N&#39;, N) &gt; 0$</span>. Begin with network <span>$N_1$</span>. Given network <span>$N_s$</span> and step <span>$s$</span>, draw a candidate network <span>$N&#39;$</span> from the initial distribution <span>$\Psi(N&#39; \mid N_s)$</span>. This candidate network <span>$N&#39;$</span> becomes <span>$N_{s+1}$</span> with probability given</p><p class="math-container">\[\mathbb{P}(N_{s+1} = N&#39; \mid N_s) = \min \left(1, \frac{\exp(\beta W(N&#39;))\Psi(N_s \mid N&#39;)}{\exp(\beta W(N_s))\Psi(N&#39; \mid N_s)}\right)\]</p><p>To understand this expression, examine the case where <span>$\Psi(N, N&#39;) = 1 \text{ for all } N, N&#39; \in \mathcal{N}$</span>. If <span>$W(N&#39;) &gt; W(N)$</span>, then <span>$N&#39;$</span> is accepted. If <span>$W(N&#39;) &lt; W(N)$</span>, then it is accepted with a probability that is increasing in <span>$W(N&#39;)$</span>. </p><p>As <span>$s \rightarrow \infty$</span>, then <span>$\mathbb{P}(N_s = N) \rightarrow \pi_\beta(N)$</span>.  </p><h2 id="Simulated-Annealing-and-Parallel-Tempering-for-Metropolis-Hastings"><a class="docs-heading-anchor" href="#Simulated-Annealing-and-Parallel-Tempering-for-Metropolis-Hastings">Simulated Annealing and Parallel Tempering for Metropolis-Hastings</a><a id="Simulated-Annealing-and-Parallel-Tempering-for-Metropolis-Hastings-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-Annealing-and-Parallel-Tempering-for-Metropolis-Hastings" title="Permalink"></a></h2><p>A downside of Metropolis-Hastings algorithms a lack of &quot;mixing&quot;. That is, we the algorithm may repeatedly draw the same sample over and over again. This problem is particularly severe in our context because of the functional form of our modified objective function, <span>$e^{\beta W(N)}$</span>. For high values of <span>$\beta$</span>, even a marginall smaller of value of <span>$W(N)$</span> will have an almost zero chance of being accepted, and the Metropolis-Hastings algorithm will be stuck in a local optimal. </p><p>Lower values of <span>$\beta$</span> will lead the Metropolis-Hastings algorithm to be less likely to stuck in a local optima. However, since marginally smaller valus of <span>$W(N)$</span> are more likely to be accepted with a small <span>$\beta$</span>, meaning the algorithm will be less likely to find optimal policies at all. The trade-off is then</p><ul><li>High values of <span>$\beta$</span> are more likely to find optimal policies, but also more likely to get stuck in a local optima and not accurately characterize the state space of optimal policies. </li><li>Low values of <span>$\beta$</span> traverse the state space of optimal policies, but the policies it draws are less likely to be optimal in general. </li></ul><p>The solution to this problem is a procedure that combines low-<span>$\beta$</span> and high-<span>$\beta$</span> runs of the Metropolis-Hastings algorithm. Low-<span>$\beta$</span> runs of the algorithm traverse the state space and search for optimal policy candidates. Later on, the high-<span>$\beta$</span> runs of the algorithm take up these optimal policy guesses and draw from the state space near these candidates. </p><p>We accomplish this general goal in two ways, with a Simulated Annealing Algorithm and with the Parallel Tempering algorithm. </p><h3 id="Simulated-Annealing"><a class="docs-heading-anchor" href="#Simulated-Annealing">Simulated Annealing</a><a id="Simulated-Annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-Annealing" title="Permalink"></a></h3><p>Simulated Annealing takes as an input a schedule of inverse temperatures <span>$\beta_1 &lt; \beta_2 &lt; \mathellipsis &lt; \beta_K$</span>. Starting with <span>$\beta_1$</span>, we run <span>$S$</span> iterations of the Metropolis-Hastings algorithm with inverse temperature <span>$\beta_1$</span>. Because <span>$\beta_1$</span> is relatively low, this algorithm quickly traverses the state space and after <span>$S$</span> iterations returns a candidate network <span>$N_1$</span>. </p><p>Next, we use this candidate network <span>$N_1$</span> as the initial state for another <span>$S$</span> runs of the Metropolis-Hastings algorithm, this time using inverse temperature <span>$\beta_2$</span>. This run will traverse the state space of policies less quickly, and will spend more time on optimal policies. This run returns candidate policy <span>$N_2$</span>, and so on, until the we return policy <span>$N_k$</span>. We are confident <span>$N_k$</span> is a globally optimal policy because previous iterations of the algorithm have thoroughly explore the state space. </p><p>To get a set of optimal policies, we run many independent runs of the Simulated Annealing algorithm. </p><h3 id="Parallel-Tempering"><a class="docs-heading-anchor" href="#Parallel-Tempering">Parallel Tempering</a><a id="Parallel-Tempering-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Tempering" title="Permalink"></a></h3><p>Parallel Tempering might be thought of as running simultaneous Simulated Annealing algorithms in parallel. We implement a textbook (naive) version of Parallel Tempering, as well as provide bindings to a more sophisticated version of the Algorithm, implemented by <a href="https://pigeons.run/stable/">Pigeons.jl</a>, which implements the algorithm described by <a href="../references/#syed2022">Syed <em>et al.</em> [2]</a>.</p><p>Like Simulated Annealing, Parallel Tempering takes as an input a schedule of inverse temperatures <span>$\beta_1 &lt; \beta_2 &lt; \mathellipsis &lt; \beta_K$</span>. It then runs separate Metropolis-Hastings algorithms for each temperature in parallel. </p><p>After <span>$S$</span> runs, each algorithm returns their latest policy candidate <span>$N_k$</span> and a &quot;swapping&quot; stage occurs. Inverse temperatures are &quot;paired up&quot; such that <span>$N_1$</span> is compared to <span>$N_2$</span>, <span>$N_3$</span> is compared to <span>$N_4$</span>, etc. For each comparison <span>$k$</span> to <span>$k+1$</span> decide whether or not the two inverse temperatures should swap policies according to </p><p class="math-container">\[\mathbb{P}(N_{k+1}&#39; = N_{k}, N_{k}&#39; = N_{k+1}) = \min\left\{1, \exp\left(\left(\beta_{k+1} - \beta_k\right) \times \left(W(N_{k}) - W(N_{k+1})\right)\right)\right\}\]</p><p>Recall that <span>$\beta_{k_1} - \beta_k &gt; 0$</span>. So when, by chance, the lower temperature returns a more optimal policy <span>$N_k$</span>, it will be accepted. Otherwise, the lower temperature policy will be accepted according to a probability determined by the <span>$\beta_{k+1} - \beta_k$</span>. </p><p>Including a Metropolis-Hastings swap stage after every <span>$S$</span> iterations in should result in a high degree of mixing, such that the Parallel Tempering algorithm can run indefinitely and draws from the time series of optimal policies produced by this algorithm mirror the distribution of optimal policies more generally. </p><p>The above describes our &quot;naive&quot; implementation Parallel Tempering. Please see <a href="../references/#syed2022">Syed <em>et al.</em> [2]</a> for a discussion of their more sophisticated algorithm. In particular, the authors do not take the inverse temperature schedule as given. Instead, we only assign a maximum inverse temperature, <span>$N_K$</span> and the schedule is determined optimally to ensure mixing. </p><h2 id="Testing-for-optimal-mixing"><a class="docs-heading-anchor" href="#Testing-for-optimal-mixing">Testing for optimal mixing</a><a id="Testing-for-optimal-mixing-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-for-optimal-mixing" title="Permalink"></a></h2><p>Given a set of policies <span>$\{N_l\}_{l =1}^{L}$</span>, how can we be sure that this set of policies is drawn from the the distribution of optimal policies <span>$\pi_\beta$</span>? We propose the following test statistic</p><p class="math-container">\[\hat{T} = \hat{W}_{\max} - \hat{W}_{\text{mean}} - \frac{\log n}{\beta}\]</p><p>Where <span>$\hat{W}_{\max}$</span> and <span>$\hat{W}_{\text{mean}}$</span> are the maximum and mean values of the the welfare values from the observed set of policies, <span>$\{W(N_l)\}_{l =1}^{L}$</span>, respectively, <span>$n$</span> represents the size of the state space (i.e. the number of different policies which can be selected), and <span>$\beta$</span> is the inverse temperature associated with this set of draws. </p><p>Asymptotically, <span>$\hat{T}$</span> is bounded above by the normal distribution of <span>$\mathcal{N}\left(0, \frac{\sigma_\pi}{L}\right)$</span>. Therefore, to test whether <span>$\{N_l\}_{l =1}^{L}$</span> are drawn independently from <span>$\pi_\beta$</span>, we use the one-sided t-test based on</p><p class="math-container">\[\frac{\hat{T}}{\hat{\sigma}_\pi / \sqrt{L - 1}}\]</p><p>where <span>$\hat{\sigma}_\pi$</span> is the estimated standard deviation of welfare values.  </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../optimal_transport/">Optimal Transport Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Thursday 29 May 2025 15:23">Thursday 29 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
